

> 在单库的情况下，我们可以通过不同的隔离级别，来解决脏读、不可重复读、幻读问题。但是，随着服务细化和微服务的发展，在日常工作中，不免就会涉及到分布式事务的问题。那么，本篇文章就来聊一聊分布式事务的解决方案有哪些。

针对于分布式事务的解决方案，广义上我们可以将其分为两类，即：**刚性事务**和**柔性事务**。

**刚性事务**：顾名思义，非常的 “**刚**”，属于硬刚的那种。这个分布式事务要么全成功，要么全回滚，别跟我提什么中间状态，我的人生中不允许出现模棱两可。其中包括：**XA**、**2PC**、**3PC**

![](https://mmbiz.qpic.cn/mmbiz_png/AZHyCoMMOC9KD2KZibARsE5LEjhicDFMD1lBKH8BiaweP8K5jqDictPhSuSeA6ZaZgVd96X4I2xVibc1ticGKpPw0YYg/640?wx_fmt=png)

**柔性事务**：相比刚性事务，柔性事务允许出现中间状态，很 “**温柔**”，像宝钗一般温柔。它别的不管，只关注最终状态，即：最终一致性一定要保证的。其中包括：**可靠事务队列**、**TCC**、**SAGA**、**基于数据补偿**。

![](https://mmbiz.qpic.cn/mmbiz_png/AZHyCoMMOC9KD2KZibARsE5LEjhicDFMD1SxFdxibChFgxVyMuMCHMeic063bFIrLLK4Cvy4OPexiaKfIXZLcjRLsEQ/640?wx_fmt=png)

在下面篇幅中，我们就来详细聊一聊。

XA
--

为了解决分布式事务一致性问题，X/Open 组织提出了一套名为 X/Open XA（XA 的缩写为：eXtended Architecture）的处理事务架构，其核心内容是定义了**全局的事务管理器**（Transaction Manager，用于协调全局事务）和**局部的资源管理器**（Resource Manager，用于驱动本地事务）之间的通信接口。XA 接口是双向的，能在一个事务管理器和多个资源管理器之间形成通信桥梁，通过协调多个数据源的一致动作，实现全局事务的统一提交或统一回滚。

XA 并**不是 Java 的技术规范**（XA 提出的时候 Java 还没有诞生），而是一套跟语言无关的通用规范，所以 Java 中专门定义了 JSR 907 Java Transaction API，基于 XA 模式在 Java 语言中实现了全局事务处理的标准，这也就是我们现在熟知的 **JTA**（Java Transaction API）。

JTA 最主要的两个接口如下所示：

*   • **事务管理器接口**（javax.transaction.TransactionManager） 这套接口用于为 Java EE 服务器提供容器事务（由容器自动负责事务管理）。JTA 还提供了另外一套 javax.transaction.UserTransaction 接口，用于通过程序代码手动开启、提交和回滚事务。
    
*   • 满足 XA 规范的**资源定义接口**（javax.transaction.xa.XAResource） 任何资源（JDBC、JMS 等）如果想要支持 JTA，只要实现 XAResource 接口中的方法即可。
    

2PC
---

### 概述

为了保证整个事务的一致性，XA 将事务提交拆分成两阶段，即：**二段式提交**（2 Phase Commit，2PC）协议。交互时序示意图如下所示：

![](https://mmbiz.qpic.cn/mmbiz_png/AZHyCoMMOC9KD2KZibARsE5LEjhicDFMD1sTNDia5Lh1bSG4wQYtuBqCa0VVRyU6Hnm98yCPbsq2BXB47Q4HL9ZSg/640?wx_fmt=png)

#### 第一阶段：准备阶段（投票阶段）

协调者**询问事务的所有参与者是否准备好提交了**，准备好恢复 Prepared，否则恢复 Non-Prepared。

准备操作是**在 redoLog 中记录全部事务提交操作所要做的内容**，它与本地事务中真正提交的区别**只是暂时不写入最后一条 Commit Record 而已**，这意味着在做完数据持久化后并不释放持有的锁。

#### 第二阶段：提交阶段（执行阶段）

如果协调者收到所有事务参与者**都回复了 Prepared 消息**，则先自己在本地持久化事务状态为 Commit，然后向所有参与者发送 Commit 指令，让所有参与者立即执行提交操作。

否则，**任意一个参与者回复了 Non-Prepared 消息**，或者任意一个参与者超时未回复时，协调者将在自己完成事务状态为 Abort 持久化后，向所有参与者发送 Abort 指令，让参与者立即执行回滚操作。

对数据库来说，提交阶段操作是**很轻量级的**，仅仅是持久化一条 Commit Record 而已，通常能够快速完成。

**只有收到 Abort 指令时，才需要根据回滚日志清理已提交的数据**，这个操作相对负载会重一些。

### 2PC 的缺点

#### 单点问题

如果协调者发生了宕机，所有的参与者都会受到影响。如果协调者一直没有恢复，没有正常发送 Commit 或 Rollback 的指令，那么**所有的参与者都必须一直等待**。

#### 性能问题

由于所有参与者相当于被绑定为一个统一调度的整体，在此期间要经过 2 次远程服务调用，3 次数据持久化（1> 准备阶段写 redoLog；2> 协调者做状态持久化；3> 提交阶段在日志写入提交记录），整个过程将持续到参与者集群中**最慢的那一个处理操作结束为止**，这导致了 2PC 的性能通常比较差。

#### 一致性风险

尽管提交阶段时间很短，但是这仍是一段明确存在的危险期，如果协调者在发出准备指令后，根据收到各个参与者发回的信息确定事务状态时可以提交的，协调者会先持久化事务状态，并提交自己的事务，**如果这个时候网络忽然断开，无法再通过网络向所有参与者发出 Commit 指令的话，就会导致部分数据（协调者的）已提交，但部分数据（参与者）未提交，且没有办法回滚，产生数据不一致的问题**。

3PC
---

**为了缓解 2PC 中协调者的单点问题和准备阶段的性能问题**，后续发展出了 “三段式提交”，即：3PC 协议。交互时序示意图如下所示：

![](https://mmbiz.qpic.cn/mmbiz_png/AZHyCoMMOC9KD2KZibARsE5LEjhicDFMD1ZDpm9icM6uf22Ziaes26mv2ic6qGoQGobDo00tlq24VQ1lAoqWJzQdebQ/640?wx_fmt=png)

3PC 把原本 2PC 中的准备阶段再细分为两个阶段，即：**CanCommit 阶段**和 **PreCommit 阶段**。把提交阶段改称为 **DoCommit 阶段**。如下图所示：

![](https://mmbiz.qpic.cn/mmbiz_png/AZHyCoMMOC9KD2KZibARsE5LEjhicDFMD1CDSlbN7icqJU7OfV6KjJZqhSJtuYuHB8Mar7PCibwSX4cicSSkS9UuQZA/640?wx_fmt=png)

**CanCommit 阶段是一个询问阶段**，即：协调者让每个参与的数据库根据自身状态，评估该事务是否有可能顺利完成。

将 2PC 的准备阶段分为 CanCommit 阶段和 PreCommit 阶段，主要是因为 **2PC 的准备阶段是一个重负载的操作，因为一旦协调者发出开始准备的消息，每个参与者都将马上开始写 redoLog，它们所涉及的数据资源即被锁住，如果此时某一个参与者宣告无法完成提交，那么所有的参与者都做了一轮无用功了。**所以，增加一轮询问阶段——即：CanCommit 阶段，如果都得到了正面的响应，那么事务能够成功提交的把握就比较大了，也就减少了所有参与者全部回滚的风险了。

综上所述，在事务需要回滚的场景中，3PC 的性能要比 2PC 好很多。但是，在事务能够正常提交的场景中，2PC 和 3PC 的性能都很差，甚至由于 3PC 多了一次询问，性能还要更差一些。

可靠事务队列
------

以快捷支付为例，当用户下单的时候，自动就进行了支付扣款操作。那么创建订单、扣减库存和支付扣款这三个操作就应该是一个原子性的操作。那么如果我们采取可靠事件队列的方式，则流程如下所示：

![](https://mmbiz.qpic.cn/mmbiz_png/AZHyCoMMOC9KD2KZibARsE5LEjhicDFMD1Aa393LKD4XibIicszoDa0SNEOyUqtG3AFB5gknXtW4BQOaF4gicZu6z0w/640?wx_fmt=png)

首先，执行创建订单操作，如果执行成功，就向**消息事件表中插入事务数据**，如下图所示：

![](https://mmbiz.qpic.cn/mmbiz_png/AZHyCoMMOC9KD2KZibARsE5LEjhicDFMD1Yjjib2hISGFgjqOwrYHEBwvmRcem4jM1uh06zvGCyG4QhPcXpv09Wvw/640?wx_fmt=png)

【注意】创建订单和写入消息事件表，使用**同一个本地事务**写入订单服务的数据库。

其次，消息服务**定时轮询**消息事务表，将状态为 “进行中” 的消息发送到 MQ 中，并且有对应的库存服务和支付服务进行消费调用操作。如果执行成功，则将响应的状态修改为 “已完成”。当某个事务 ID 下所有的行为状态都是“已完成” 状态时，则表示整个事务总体成功的，即：达到最终一致性的状态。

如果扣减库存或者账户扣款失败了，那么状态依然是 “进行中”。当消息服务定时轮询再次抓取到状态为“进行中” 的消息时，会再次重试扣减库存或扣款操作。所以，这些**接口必须具备幂等性**，否则就会出现重复操作的问题。

可靠事件队列的特点就是：**如果某个服务无法完成工作，那么就会一直重试，直到操作成功或是人工介入**。由此可见，可靠事务队列只要第一步业务完成了，后续就没有失败回滚的概念，只许成功，不许失败。

TCC
---

TCC 是 **“Try-Confirm-Cancel”** 的缩写，是常见的分布式事务机制。

在具体实现上，TCC 较为繁琐，它是一种**业务侵入式较强**的事务方案，要求业务处理过程必须拆分为 “预留业务资源” 和“确认 / 释放消费资源”两个子过程。如同 TCC 的名字所示，它分为以下三个阶段：

*   • **Try**（尝试执行阶段）  
    完成所有业务可执行性的检查（保障一致性），并且预留好全部需要用到的业务资源（保障隔离性）。
    
*   • **Confirm**（确认执行阶段）  
    不进行任何业务检查，直接使用 Try 阶段准备的资源来完成业务处理。Confirm 阶段可能会重复执行，因此本阶段执行的操作需要具备幂等性。
    
*   • **Cancel**（取消执行阶段）  
    释放 Try 阶段预留的业务资源。Cancel 阶段可能会重复执行，因此本阶段执行的操作需要具备幂等性。
    

上述我们了解了 TCC 模式，那么下面还是以快捷支付为例，看一下 TCC 的执行过程：

![](https://mmbiz.qpic.cn/mmbiz_png/AZHyCoMMOC9KD2KZibARsE5LEjhicDFMD1DaQshCh19lOicegvicJWrJQluAuxygsOUkQkVlib9g2ibiaXnR7CGzFXyNg/640?wx_fmt=png)

由上述操作过程可见，TCC 其实有点**类似 2PC 的准备阶段和提交阶段**。但 TCC 是在用户代码层面，而不是在基础设施层面，这为它的实现带来了**较高的灵活性**，可以根据需要设计资源锁定的粒度。

TCC 在业务执行时**只操作预留资源，几乎不会涉及锁和资源的争用**，具有很高的性能潜力。但 TCC 也带来了**更高的开发成本和业务侵人性**，即更高的开发成本和更换事务实现方案的替换成本，所以，通常我们并不会完全靠裸编码来实现 TCC，而是基于某些分布式事务中间件 (管如阿里开源的 Seata）去完成，尽量减轻一些编码工作量。

SAGA
----

在一些场景下，**如果无法实现冻结、解冻、扣减这样的操作的话，那么 TCC 中的第一步 Try 阶段就无法施行了。**此时，我们可以考虑使用另外一种柔性事务——SAGA 事务。

SAGA 事务大致思路是：**把一个大事务分解为可以交错运行的一系列子事务集合**。原本 SAGA 的目的是避免大事务长时间锁定数据库资源，后来才发展成将一个分布式环境中的大事务分解为一系列本地事务的设计模式。

![](https://mmbiz.qpic.cn/mmbiz_png/AZHyCoMMOC9KD2KZibARsE5LEjhicDFMD1iaKTowialhYib7u0icxM968yicPAQ7AcJCJib05HXwDpC72cgq5ZeXYY75xg/640?wx_fmt=png)

SAGA 由两部分操作组成：

*   • 第一部分：**将大事务拆分成若干个小事务**，将整个分布式事务 T 分解为 n 个子事务，命名为 T1，T2，T3 ... ，Tn。每个子事务都应该是或者能被视为原子行为。如果分布式事务能够正常提交，其对数据的影响（即：最终一致性）应与连续按顺序成功提交 Ti 等价。  
    
*   • 第二部分：**为每一个子事务设计对应的补偿动作**，命名为 C1，C2，C3...，Cn。Ti 与 Ci 必须满足以下条件：  
    1> Ti 与 Ci 都具备幂等性。  
    2> Ti 与 Ci 满足交换律，即：无论先执行 Ti 还是先执行 Ci，其效果都是一样的。  
    3> Ci 必须能成功提交，即：不考虑 Ci 本身提交失败被回滚的情形，如果出现就必须持续重试直至成功，或者被人工介入为止。  
    

如果 T1 到 Tn 均成功提交，那事务顺利完成。否则，要采取以下两种恢复策略之一：

*   • 恢复策略一：**正向恢复**（Forward Recovery）  
    如果 Ti 事务提交失败，则一直对 Ti 进行重试，直到成功为止（最大努力交付）。这种恢复方式不需要补偿，适用于事务最终都要成功的场景。正向恢复的执行模式为：T1，T2，...，Ti（失败），Ti（重试），...，Ti+1，...，Tn。
    
*   • 恢复策略二：**反向恢复**（Backward Recovery）  
    如果 Ti 事务提交失败，则一直执行 Ci 对 Ti 进行补偿，直至成功为止（最大努力交付）。这里要求 Ci 必须（在持续重试后）执行成功。反向恢复的执行模式为：T1，T2，...，Ti（失败），Ci（补偿），...，C2，C1。
    

与 TCC 相比，**SAGA 不需要为资源设计冻结状态和撤销冻结的操作，补偿操作往往要比冻结操作容易实现得多**。

SAGA 必须保证所有子事务都得以提交或者补偿，但 SAGA 系统本身也有可能会崩溃，所以它**必须设计成与数据库类似的日志机制（被称为 SAGA Log）**以保证系统恢复后可以追踪到子事务的执行情况，比如执行到哪一步或者补偿到哪一步了。

SAGA 事务通常也不会直接靠裸编码来实现，一般是在事务中间件的基础上完成，例如利用 Seata 的 SAGA 事务模式。

基于数据补偿
------

seata 的 AT 模式就是**基于数据补偿来代替回滚思路**的。

AT 事务是**参照了 XA 两段提交协议实现的**，但是 AT 并不需要等待所有数据源都返回成功采取执行全局提交，而是**通过了拦截 SQL 的方式，生成前后镜像，生成行锁**，通过**本地事务**一起提交到操作的数据源中，相当于自己记录了重做和回滚日志。

如果分布式事务**成功提交**，那后续清理每个数据源中对应的日志数据即可；

如果分布式事务**需要回滚**，就根据日志数据自动产生用于补偿的 “逆向 SQL”。

![](https://mmbiz.qpic.cn/mmbiz_png/AZHyCoMMOC9KD2KZibARsE5LEjhicDFMD1txic8IIWfumEEur58z1DADSZSmiaWxoiaIRD9Gch0yQZMwCNWW1syX7nA/640?wx_fmt=png)

采用 AT 模式，效率要比 2PC 这种阻塞式高很多。但是却**丧失了隔离性**。譬如：在本地事务提交之后，分布式事务完成之前，该数据被补偿之前又被其他操作修改过，即：出现了脏写，那么此时一个分布式事务需要回滚，就不可能再通过自动的逆向 SQL 来实现补偿，**只能由人工接入来处理了**。但是其实也很难通过人工进行有效处理。所以 Seata 增加了**全局锁的机制**来实现写隔离，要求本地事务提交之前，一定要先拿到针对修改记录的全局锁后才允许提交，如果没有获得全局锁就必须一直等待。

这种设计以牺牲一定性能作为代价，避免了两个分布式事务中包含的本地事务修改同一个数据的情况，从而避免脏写。但是这种**全局锁的方式性能消耗太大，一般不会这样做**，需要根据实际业务场景进行取舍。

总结
--

以上的内容，基本完整地介绍了分布式事务的解决方案。其实没有哪一种解决方案是最好的，同理，也没有哪个解决方案是最差的，有的只是最适合大家的。同学们可以根据具体业务和现状进行选择。

最近看了一本书，叫《认知觉醒》，周岭写的。书里的内容写得很好，其中有一章，介绍他每天早起的经历。里面有个理论蛮有意思的，跟大家分享一下，书中的大意是这样的：“人在睡眠的前 3 个小时属于深度睡眠，此后每 1.5 个小时会在深度睡眠和浅度睡眠两种模式不断切换。” 换句话说，人的睡眠是有规律的，在睡眠后的 3 小时、4.5 小时、6 小时、7.5 小时这几个节点如果醒来，就会觉得神清气爽，精力充沛。而我们平时采用闹钟的方式定点起床，很大概率被吵醒的时间点我们还在深度睡眠或者浅度睡眠的过程中，所以醒来的时候一般都会很困很难受。

并且他根据以上的理论，已经在 4 年里每天早上 4 点左右起床，重要的是，**不再需要闹钟的提醒**。那么他就将他的一天分成了如下 3 个阶段：

*   • 第一阶段：早上 4 点——中午 12 点
    
*   • 第二阶段：中午 12 点——晚上 8 点
    
*   • 第三阶段：晚上 8 点——次日早上 4 点
    

在上面的 3 个阶段中，他既保证了睡眠质量，又比大多数人更多地 “拥有了白天的时间”。

看完之后，我个人也开始去尝试和关注这个睡眠规律。每天晚上 10 点左右睡觉，很神奇的是，我发现自己也可以不用闹钟的情况下，早上 5 点左右自然醒来（当然，如果要睡回笼觉的话，我觉得我也能很快睡着），而且精神状态很好。醒来后做了很多工作一看时间，还是上午，这种感觉其实还是挺不错的。如果大家感兴趣的话，可以尝试一下哈。

行了，今天就这么多内容了，我们下篇文章再见啦！