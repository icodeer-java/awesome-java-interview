> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s?__biz=MzI0MTE0NTc0Ng==&mid=2247484494&idx=1&sn=eda2e30bca0fc925fc8c3fd16b2b308c&chksm=e91146b3de66cfa516234f3974f1e77eccc18f9b85830557e7a535cdf941edd2a06e1e602c8c&scene=178&cur_album_id=2142543588444995585#rd)

一、解决并发事务带来的问题
=============

1.1> 写 - 写情况
------------

*   由于任何一种隔离级别都不允许脏写（写 - 写）的现象发生，所以，当**多个未提交事务**相继对**一条记录**进行改动的时候，就需要让它们**排队**执行。
    
*   这个排队的过程其实是通过为该记录**加锁**来实现的。这个锁本质上是一个**内存中的结构**。
    

*   写 - 写具体操作流程如下：
    

*   1> 一开始是没有**锁结构**与记录进行关联的，即：下图第一个图例所示。
    
*   2> 当一个事务 T1 想对这条记录进行改动时，会看看**内存中有没有与这条记录关联的锁结构**，如果没有，就会在内存中**生成一个锁结构**与这条记录相关联，即：下图第二个图例所示。我们把该场景称之为**获取锁成功** / **加锁成功**。
    
*   3> 此时又来了另一个事务 T2 要访问这条记录，发现这条记录已经有一个锁结构与之关联了，那么 T2 也会生成一个锁结构与这条记录关联，不过锁结构中的 **is_waiting 属性值为 true**，表示需要等待。即：下图第三个图例所示。我们把该场景称之为**获取锁失败** / **加锁失败**。
    
*   4> 事务 T1 提交之后，就会把它生成的锁结构释放掉，然后检测一下还有没有与该记录关联的锁结构。结果发现了事务 T2 还在等待获取锁，所以把事务 T2 对应的锁结构的 **is_waiting 属性设置为 false**，然后把该事务对应的线程唤醒，让 T2 继续执行。
    

*   整体流程如下所示：
    

![](https://mmbiz.qpic.cn/mmbiz_png/AZHyCoMMOCibAnol8HUF5H7WPuFenoCCicEhymOicMLZkLsXYnHvWe9ibqticb2nRMtiaibAGtypF48ic9ccoib3icnB7o8g/640?wx_fmt=png)

1.2> 读 - 写或写 - 读情况  

---------------------

*   为了避免在 “读 - 写” 或“写 - 读”情况下避免脏读、不可重复读、幻读现象，有如下两种可选的解决方案：
    

*   1> 读操作使用多版本并发控制（MVCC），写操作进行加锁。
    
*   2> 读、写操作都采用加锁的方式。
    

*   MySQL 与 SQL 标准不同的一点就是，MySQL 在 REPEATABLE READ 隔离级别下很大程度地避免了幻读现象。
    

1.3> 一致性读  

------------

*   一致性读 / 一致性无锁读 / 快照读
    

     定义：事务**利用 MVCC** 进行的读取操作。

*   所有**普通的 SELECT 语句**在 READ COMMITTED 或 REPEATABLE READ 隔离级别下都算是一致性读。比如：
    

```
select * from student;
select * from student s left join address a on s.addr_id = a.id;

```

*   一致性读并**不会对表中的任何记录进行加锁**操作，其他事务可以自由地对表中的记录进行改动。
    

1.4> 锁定读  

-----------

在使用加锁的方式来解决读写问题的时候，由于既要允许读 - 读情况不受影响，又要使写 - 写或读 - 写情况中的操作互相阻塞，所以 MySQL 给锁分为以下两类：

*   共享锁（S 锁）
    

 **Shared Lock**：在事务要**读取**一条记录时，需要先获取该记录的 **S 锁**。

*   独占锁（X 锁）
    

 **Exclusive Lock**：在事务要**修改**一条记录时，需要先获取该记录的 **X 锁**。

*   S 锁和 X 锁的兼容关系
    

![](https://mmbiz.qpic.cn/mmbiz_png/AZHyCoMMOCibAnol8HUF5H7WPuFenoCCictMcyslmC9YAIs0t2nx1FOq8MOk4Z5nwuWFa1GeyBYjicwN85ib6fLIkQ/640?wx_fmt=png)

【举例解释】

*   情况 1：事务 T1 首先获取了一条记录的 **S 锁**
    

如果事务 T2 也要获得这条记录的 S 锁，那么此时，T2 是可以获得这条记录的 S 锁。如果事务 T2 要获得这条记录的 X 锁，那么操作会被阻塞，直到事务 T1 提交之后将 S 锁释放掉为止。

*   情况 2：事务 T1 首先获取了一条记录的 **X 锁**
    

那么无论事务 T2 要获得这条记录的 S 锁还是 X 锁，T2 都会被阻塞，直到事务 T1 提交之后将 X 锁释放掉为止。

*   锁定读的语句
    

        对读取的记录**加 S 锁**

 **SELECT ...** **LOCK IN SHARE MODE;**

        对读取的记录**加 X 锁**

 **SELECT ...** **FOR UPDATE;**

1.5> 写操作  

-----------

*   DELETE
    

      先在 B + 树中**定位**到这条记录的位置，然后获取这条记录的 **X 锁**，最后再执行 **delete mark** 操作。

*   INSERT
    

      一般情况下，新插入的一条记录受**隐式锁**保护，不需要在内存中为其生成对应的锁结构。

*   UPDATE
    

     分为如下 3 种情况：

*   **未修改主键**并且被更新的列在修改前后所占用的**存储空间未发生变化**
    

先在 B + 树中**定位**到这条记录的位置，然后获取这条记录的 **X 锁**，最后在原记录的位置进行修改操作。

*   **未修改主键**并且被更新的列在修改前后所占用的**存储空间发生变化**
    

先在 B + 树中**定位**到这条记录的位置，然后获取这条记录的 **X 锁**，之后将原记录彻底删除掉（即：把记录彻底移入垃圾链表），最后再插入一条新记录。

*   **修改主键**
    

相当于在原记录上执行 **DELETE 操作**之后再来一次 **INSERT 操作**。加锁操作就需要按照 DELETE 和 INSERT 的规则进行了。

二、多粒度锁  

=========

*   上面提到的锁都是针对记录的，可以称为**行级锁** / **行锁**；对一条记录加行锁，影响的只是该行记录而已，所以行锁的粒度比较细。
    
*   如果一个事务在表级别进行加锁，就称为**表级锁** / **表锁**。它会影响表中的所有数据，锁的粒度比较粗。
    

*   **表锁**也可以分为**共享锁（S 锁）**和**独占锁（X 锁）**
    

*   情况 1：一个事务给表加了 S 锁
    

    其他事务**可以**继续获得该**表** / 该表中的某些**记录**的 **S 锁**。

    其他事务**不可以**继续获得该**表** / 该表中的某些**记录**的 **X 锁**。

*   情况 2：一个事务给表加了 X 锁
    

    其他事务**不可以**继续获得该**表** / 该表中的某些**记录**的 **X 锁**或 **S 锁**。

*   每当要对表上 S 锁的时，需要表中的记录和表没有 X 锁；当要对表上 X 锁的时候，需要表中的记录和表即没有 X 锁也没有 S 锁。那么，表上的锁比较好判断，_记录上的锁怎么判断呢？_总不能一行一行的来判断是不是有 X 锁或者 S 锁把。那么，为了解决这个问题，InnoDB 提出了**意向锁**的概念。即：
    

*   意向共享锁（**IS 锁**）
    

ntention Shared Lock：当事务准备在某条**记录**上加 S 锁时，首先需要在**表级别**加一个 IS 锁。

*   意向独占锁（**IX 锁**）
    

Intention Exclusive Lock：当事务准备在某条**记录**上加 X 锁时，首先需要在**表级别**加一个 IX 锁。

*   **IS 锁**和 **IX 锁**是**表级锁**，它们的提出仅仅**为了在之后加表级别的 S 锁和 X 锁时可以快速判断表中的记录是否被上锁**，以避免用遍历的方式来查看表中有没有上锁的记录；也就是说，其实 **IS 锁和 IX 锁是兼容的**，**IX 锁和 IX 锁是兼容的**，**IS 和 IS 也是兼容的**。兼容性关系如下所示：
    

*   表级别的锁的兼容性
    

![](https://mmbiz.qpic.cn/mmbiz_png/AZHyCoMMOCibAnol8HUF5H7WPuFenoCCicd4BqicFtibnJyI1oQCGibdehuhhVBFAFyemW7uy7gxHm5RpuJV4LxkxvQ/640?wx_fmt=png)

三、MySQL 中的行锁和表锁  

==================

3.1> 其他存储引擎中的锁
--------------

*   对于 MyISAM、MEMORY、MERGE 这些存储引擎来说，它们**只支持表级锁**，而且这些存储引擎并**不支持事务**。
    

3.2> InnoDB 存储引擎中的锁
-------------------

*   InnoDB 存储引擎**既支持表级锁也支持行级锁**
    

### 3.2.1>  InnoDB 中的表级锁  

#### a> S 锁、X 锁

*   InnoDB 存储引擎提供的**表级** S 锁或者 X 锁相当 “鸡肋”，在对某个表执行 SELECT、INSERT、DELETE、UPDATE 语句时，**InnoDB 存储引擎是不会为这个表添加表级别的 S 锁或者 X 锁的**，只会在一些特殊情况下（比如系统崩溃恢复时）用到。
    
*   在对某个表执行 DDL 语句时，其他事务在对这个表并发执行 DML 语句时，会发生阻塞；反之亦然。这个过程其实是通过在 server 层使用一种称为**元数据锁**（Metadata Lock，MDL）的东西来实现的，也不会使用 S 锁和 X 锁。
    

*   DDL 语句在执行时会**隐式提交**当前会话中的事务
    

     原因：DDL 语句的执行一般都会在若干个特殊事务中完成。在开启这些特殊事务前，需要将当前会话中的事务提交掉。

*   虽然表级 S 锁或 X 锁相当鸡肋，不过我们还是可以手动获取一下的，比如在系统变量 **autocommit=0**、**innodb_table_lock=1** 时，可以按照下面来写语句：
    

*   **LOCK_TABLES t READ**
    

对表 t 加表级别的 S 锁。

*   **LOCK_TABLES t WRITE**
    

对表 t 加表级别的 X 锁。

#### b> IS 锁、IX 锁

*   IS 锁和 IX 锁是表级锁，它们的提出仅仅**为了在之后加表级别的 S 锁和 X 锁时可以快速判断表中的记录是否被上锁**，以避免用遍历的方式来查看表中有没有上锁的记录；
    

#### c> AUTO-INC 锁

*   系统自动给 AUTO_INCREMENT 修饰的列进行递增赋值的实现方式主要有下面两个：
    

*   AUTO-INC 锁
    

执行插入语句时就加一个表级别的 AUTO-INC 锁，然后为每条待插入记录的 AUTO_INCREMENT 修饰的列分配递增的值。

在该语句执行结束后，再把 AUTO-INC 锁释放掉。这样一来，一个事务在持有 AUTO-INC 锁的过程中，其他事务的插入语句都要被阻塞。

AUTO-INC 锁的作用范围只是**单个插入**语句，在插入语句执行完成后，这个锁就被释放了。

*   轻量级锁
    

在通过 AUTO_INCREMENT 获得修饰的列的值时获取这个轻量级锁，就把该轻量级锁释放掉，而不需要等到整个插入语句执行完后才释放锁。

*   innodb_autonic_lock_mode 系统变量，用来控制到底使用上述两种方式中的哪一种
    

*   innodb_autonic_lock_mode=0
    

一律采用 AUTO_INC 锁。

*   innodb_autonic_lock_mode=2
    

一律采用轻量级锁。

*   innodb_autonic_lock_mode=1
    

两种方式混着来，即：插入记录的数量**确定时**采用轻量级锁，**不确定时**采用 AUTO-INC 锁。

其中，不确定插入记录数量的情况。

例如：INSERT...SELECT、REPLACE...SELECT、LOAD DATA。

### 3.2.2>  InnoDB 中的行级锁  

*   行级锁，也称为记录锁，顾名思义就是在记录上加锁。
    
*   不过行锁也根据不同的类型分为了多种。也就是说，即使对同一条记录加行锁，如果记录的类型不同，起到的功效也是不同的。
    

#### a> Record Lock

*   官方名称：LOCK_REC_NOT_GAP
    

*   也称为**记录锁**：也就是仅仅负责把一条记录锁上的锁。
    
*   记录锁也分为：**S 型**记录锁和 **X 型**记录锁。
    

*   如下图所示：
    

![](https://mmbiz.qpic.cn/mmbiz_png/AZHyCoMMOCibAnol8HUF5H7WPuFenoCCictCAXzU4dxmb2JU6ibrxImQd56f8KyJPT4fFI5Pse5ia6tpxvW22Wl1CQ/640?wx_fmt=png)

#### b> Gap Lock

*   官方名称：LOCK_GAP
    
*   也称为 **gap 锁**：锁住了指定的记录以及记录前面的间隙，防止其间插入新记录。
    
*   gap 锁的提出仅仅是为了**防止插入幻象记录**（即：幻读现象）而提出的。                                                                                                                  
    
*   如下图所示：
    

![](https://mmbiz.qpic.cn/mmbiz_png/AZHyCoMMOCibAnol8HUF5H7WPuFenoCCicwIjpryVLz9FQ3NhAW7y3flCrw5zgdzWicZjKojctozyGZdnhXDbabxg/640?wx_fmt=png)【解释】

      意味着不允许别的事务在 no 值为 5 的**记录前面的间隙**插入新记录，即：no 列的值在区间（3，5）的新记录是不允许立即插入的，当 gap 锁释放才可以插入。

*   如何锁定 no 值为 5 之后的记录呢？
    

      为 Supremum 记录加一个 gap 锁，则可以阻止其他事务插入 no 值在区间（5, +∞）的新纪录。

#### c> Next-Key Lock

*   官方名称：LOCK_ORDINARY
    
*   也称为 **next-key 锁**：本质就是一个**记录锁** +**gap 锁**的合体。它既能保护该条记录，又能阻止别的事务将新纪录插入到被保护记录前面的间隙中。
    

*   如下图所示：
    

![](https://mmbiz.qpic.cn/mmbiz_png/AZHyCoMMOCibAnol8HUF5H7WPuFenoCCicq8giaefCUuykHxlavicXc8mal27TPJjvvCtTrjgEM6UYWUro2EeYyCDA/640?wx_fmt=png)

#### d> Insert Intention Lock

*   官方名称：LOCK_INSERT_INTENTION
    
*   也称为**插入意向锁**：事务在等待时也需要在内存中生成一个锁结构，表明有事务想在某个间隙中插入新记录，但是现在处于等待状态。
    

*   如下图所示：
    

![](https://mmbiz.qpic.cn/mmbiz_png/AZHyCoMMOCibAnol8HUF5H7WPuFenoCCicrlyYFGcXnJS5ia1zYIy3epVWrKwyhJsjwvN4mXkVXfR2wKMPed1cIew/640?wx_fmt=png)【解释】

 **type 属性**，用来表明该锁的类型。

    由于 T1 持有 no=9 的 gap 锁（即：no 等于 5~9 之间不能插入记录），所以 T2 和 T3 分别想插入 no=6 和 no=7 的两条记录时会生成插入意向锁的锁结构并且处于等待状态。

    本质上就是把插入意向锁对应锁结构的 is_waiting 置为 true。

    当 T1 提交后会把 gap 锁释放掉，这时候，**T2 和 T3 之间也并不会相互阻塞**，他们可以同时获取到 number 值为 9 的插入意向锁，然后执行插入操作。

*   事实上**插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁**，就是这么鸡肋。
    

#### d> 隐式锁

*   一般情况下，执行 INSERT 语句是不需要在内存中生成锁结构的。
    
*   但是也会有例外，比方说：一个事务首先插入了一条记录 (此时并没有与该记录关联的锁结构），然后另一个事务执行如下操作：
    

*   立即使用 SELECT... LOCK IN SHARE MODE 语句读取这条记录 （也就是要获取这条记录的 S 锁），或者使用 SELECT ... FOR UPDATE 语句读取这条记录（也就是要获取这条记录的 X 锁），该咋办？如果允许这种情况的发生，那么可能出现**脏读现象**。
    
*   立即修改这条记录（也就是要获取这条记录的 X 锁），该咋办？如果允许这种情况的发生，那么可能出现**脏写现象**。
    

*   解决办法——使用事务 id，我们把聚簇索引和二级索引中的记录分开看一下
    

*   场景 1：对于**聚簇索引**
    

有一个 **trx_id** 隐藏列，该隐藏列记录着最后改动该记录的事务 id。在当前事务中新插入一条聚簇索引记录后，该记录的 trx_id 隐藏列代表的就是当前事务的事务 id。如果其他事务此时想对该记录添加 S 锁或者 X 锁，首先会看一下**该记录的 trx_id 隐藏列代表的事务是否是当前的活跃事务**。如果不是的话就可以正常读取：如果是的话，那么就帮助当前事务创建一个 X 锁的锁结构，该锁结构的 is_waiting 属性为 false：然后为自己也创建一个锁结构，该锁结构的 is_ waiting 属性为 true，之后自己进入等待状态。

*   场景 2：对于**二级索引**
    

本身并没有 trx_id 隐藏列，但是在二级索引页面的 Page Header 部分有一个 **PAGE_MAX_TRX_ID** 属性，该属性代表对该页面做改动的最大的事务 id。如果 **PAGE_MAX_TRX_ID 属性值小于当前最小的活跃事务 id**，那就说明对该页面做修改的事务都己经提交了，否则就需要在页面中定位到对应的二级索引记录，然后通过回表操作找到它对应的聚筷索引记录，然后再重复情景 1 的做法。

*   综上所述，隐式锁起到了**延迟生成锁结构**的用处。即：一般情况不生成隐式锁，如果发生上述冲突的锁操作，则采用隐式锁结构来保护记录。